서버가 통신하는 대상을 식별하는 데 사용하는 기술을 알아본다.

### 11.1 개별 접촉

HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다. 
(연결 자체에 대한 정보를 가지지 않으며 매 요청은 일회성이고 독립적으로 처리된다. -> stateless 무상태)

웹서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어 한다.
 
 * 개별 인사 : 사용자들에게 특화된 페이지를 만든다.
 * 사용자 맞춤 추천
 * 저장된 사용자 정보 : 주소나 신용카드와 같이 편리성 제공
 * 세션 추적 

HTTP 트랜젝션은 상태가 없다. 위와 같은 서비스를 제공하기 위해서는 웹 사이트는 각 사용자에게서 오는 HTTP 트랜젝션을 식별할 방법이 필요하다.

이 장에서는 아래와 같은 사용자 식별 기술을 논의한다.
* 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
* 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
* 사용자 로그인 인증을 통한 사용자 식별
* URL에 식별자를 포함하는 기술인 뚱뚱한 URL
* 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

### 11.2 HTTP 헤더

사용자에 대한 정보를 전달하는 일반적인 헤더들이 존재한다. 

##### FROM (요청)
헤더에 사용자의 이메일 주소를 포함한다. 사용자를 식별할 수는 있지만, 악의적인 서버가 헤더를 모아 이메일 주소로 스펨메일을 발송할 수 있는 문제가 있다.

##### User-Agent (요청)
사용자의 브라우저 이름과 버전 정보 등 포함하여 서버에 요청한다. 특정 브라우저에 대한 최적화하는데 유용하게 사용될 수는 있지만, 특정 사용자 식별은 불가능하다.

##### Referer(요청)
사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다. 
사용자 식별은 불가능하지만, 사용자가 이전에 어떤 페이지에 있었는지는 알려준다. 이 헤더를 통해 사용자의 웹 사용 형태나 취향을 파알살 수 있다.

##### Authorization(요청)
사용자 이름과 비밀번호
##### Client-ip(요청-확장)
클라이언트의 IP 주소
##### X-Forwarded-For(요청-확장)
클라이언트의 IP 주소
##### Cookie (요청-확장)
서버가 생성한 ID 라벨

### 11.3 클라이언트 IP 주소
클라이언트 IP 주소로 사용자를 식별하는 방식은 아래와 같은 이유로 특정 사용자 식별이 어려울 수 있다.
* IP는 사용자가 아닌 컴퓨터를 가리킨다. 여러명이 하나의 컴퓨터를 이용할 경우
* 동적으로 IP를 할당 받는 경우
* 보안을 위해 사용자가 네트워크 주소 변환(NAT) 방화벽을 사용하여 실제 IP 주소를 방화벽 뒤로 숨기고 내부 IP 주소로 변환할 경우
* 프락시 서버를 거칠 경우 (X-Forwarded-For 헤더 사용할 수 있지만 이런식으로 동작하지 않을 수 있다. )

### 11.4 사용자 로그인 (인증)
웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.

HTTP는 WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.

1. 클라이언트가 서버에 요청 시 인증이 필요할 경우 
2. 서버는 401의 상태 코드와 WWW-Authenticate 헤더를 반환한다.
3. 사용자는 헤더에 인증 정보를 작상하여 서버에 요청한다. (Authorization: Basic am910jRmdW4=)
4. 이 시점 이후 브라우저는 Authorization 헤더를 포함시켜 한 세션이 진행되는 동안 사용자에 대한 식별을 유지한다.

### 11.5 뚱뚱한 URL
사용자에게 할당된 식별번호를 URL 뒤에 붙여 사용자를 추적한다.
```
<a href="/exec/test/ref=gr_gifts/002-114532847-12423"> All Gifits </a>
```
문제점 : 
* URL이 길어 사용자에게 혼란을 줌. 
* 해당 식별번호를 공유할 경우. 
* 요청별로 URL이 달라 캐시 사용 불가능함.
* URL 이탈 후 다시 복귀 했을 경우 기존 사항들(장바구니..) 초기화
* 사용자가 식별번호를 보관하고 있어야 함. (북마크 이용해서) 

### 11.6 쿠키

#### 11.6.1 쿠키의 타입
쿠키는 세션 쿠키(session cookie)와 지속 쿠키(persistent cookie)로 나눌 수 있다.

세션 쿠키는 사용자가 브라우저를 닫으면 삭제 된다. 지속 쿠키는 디스크에 저장되어 컴퓨터를 재시작해도 남아있다. 지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.

#### 11.6.2 쿠키는 어떻게 동작하는가
웹 서버는 사용자를 식별하기 위해 임의의 이름=값 형태의 리스트를 Set-Cookie 혹은 Set-Cookie2와 같은 HTTP 응답 헤더에 기술하여 사용자에게 전달한다.

브라우저는 서버로 온 Set-Cookie 혹은 Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다. 이후 동일한 사이트 방문 시 브라우저는 헤당 쿠키를 Cookie 요청 헤더에 작성하여 전달한다.

#### 11.6.3 클라이언트 측 상태 (HTTP 상태 관리 체계)
브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 '클라이언트 측 상태' 라고 한다. 공식적인 이름은 'HTTP 상태 관리 체계'임.

각 브라우저는 다른 방식으로 쿠키를 저장한다. 
##### 구글 크롬 쿠키
Cookies라는 SQLite 파일에 쿠키를 저장한다. 
##### IE
캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장한다.

#### 11.6.4 사이트마다 다른 쿠키들
브라우저는 수천 개의 쿠키를 가지고 있을 수 있지만, 쿠키 전부를 모든 사이트에 보낼 수는 없다.(네트워크 비용 문제, 개인정보 문제 등)

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 제공한다. 
test.com에서 생성한 쿠키는 test.com 요청 시에만 보낸 다던지...

Path 속성을 이용해 동일한 도메인이더라도 일부 Path에만 쿠키를 적용할 수도 있다.  Set-Cookie: pref=compact; dmain="test.com"; path=/specials/

#### 11.6.9 쿠키와 캐싱
##### 캐시되지 말아야 할 문서가 있다면 표시하라
##### Set-Cookie 헤더를 캐시 하는 것에 유의하라
Set-Cookie 헤더가 있다면 본문은 캐시할 수 있지만 헤더를 캐시하는 것은 주의를 기울여야만 한다.
캐시된 헤더를 여러 사용자에게 보내면 사용자 식별이 어렵다.
Cache-Control: must-revalidate, max-age=0 헤더를 추가하여 재검사가 일어날 수 있게 해야 한다. 
##### Cookie 헤더를 가지고 있는 요청을 주의하라. 
요청이 Cookie와 함께 오면 결과 콘텐츠가 개인정보를 담고 있을 수도 있다. 개인정보는 캐시되면 안된다. 
보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것이다. 

#### 11.6.10 쿠키, 보안 그리고 개인정보
쿠키를 사용하지 않도록 비활성화 시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것도 가능하므(?) 보안상으로 엄청 위험한 것은 아니다. 
원격 데이터베이스에 개인 정보를 저장하고, 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면 예민한 데이터가 오가는 것을 줄일 수 있다.

쿠키의 위험성이 과대평가 되었다는 평가서 내용 일부(http://attrition.org/security/advisory/ciac/i-fy98/ciac.i-034.internet.cookies)
