## 기본 인증

### 12.2 인증
#### 12.1.1 HTTP의 인증요구/응답 프레임워크 
HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다. 

웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답할 수 있다. 인증정보가 맞으면 요청은 처리가 된다. 

#### 12.1.2 인증 프로토콜과 헤더
HTTP에는 기본 인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다. 

인증 헤더 형식
##### WWW-Authenticate (401)
서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려한다. 서버에는 각각 다른 비밀번호가 있는 영역이 있을 것이므로 서버는 WWW-Authenticate 헤더에 해당 영역을 설명해 놓는다.  

##### Authorization (GET)
클라이언트가 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authorization 헤더를 함께 보낸다.

##### Authentication-Info (200)
인증 성공 시 세션 정보와 같은 추가 정보를 기술해서 Authentication-Info 헤더와 함께 응답할 수 있다. 

#### 12.1.3 보안 영역
HTTP가 각 리소스마다 다른 접근 조건을 다루는지 설명한다. 

서버가 클라이언트로 인증을 요구할때 realm 지시자를 기술한 WWW-Authenticate 헤더로 클라이언트에 응답한다. 웹 서버는 기밀문서를 보안 영역(realm)그룹으로 나누어 사용자가 리소스마다 다르게 접근 할 수 있도록 구분 한다.

인증 요청 응답
```
HTTP/1.0 401 Authorization Required
WWW-Authenticate: Basic realm="Family"
```

### 12.2 기본 인증
기본 인증에서 웹 서버는 클라이언트의 요청을 거부하고 401 상태 코드와 함게 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 인증 요구를 시작한다.

이때 브라우저는 대화상자를 통해 아이디와 비밀번호를 입력받는데, 해당 정보를 Authorization 요청 헤더 안에 암호화 해서 서버로 다시 보낸다.

#### 12.2.1 기본 인증의 예
클라이언트에서 서버로 인증 정보 전송 시에는 사용자 이름과 비밀번호는 콜론으로 잇고, base-64로 인코딩해서 사용자 이름과 비밀번호에 쉽게 국제문자를 포함할 수 있게 하고, 네트워크 트래픽에 사용자 이름과 비밀번호가 노출되지 않게 한다.

Authorization: Basic base-64로 인코딩한 사용자 이름과 비밀번호

기본 인증 프로토콜은 Authentication-Info 헤더를 사용하지 않는다.

#### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩
예를 들어 사용자 이름은 'brian-totty'이고 비밀번호가 'Ow!'이면 브라우저는 이름과 비멀번호를 콜론으로 이어서 'brian-totty:Ow!'를 만들고, 해당 문자열을 base-64로 인코딩해서 'YnJpYW4tdG90dHk6T3ch'를 만든다.

base-64 인코딩은 어떤 시스템에서는 문제를 일으킬 수 있는 문자열(국제 문자 데이터, 큰따옴표 등)을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다.

### 12.3 기본 인증의 보안 결합
1. 문자열을 가로채서 쉽게 디코딩할 수 있다.
2. 디코딩이 어려워도 인코딩된 문자열로 서버에 인증 요청할 수 있다.
3. 비밀번호 노출이 쉽기 때문에 노출 시 동일한 비밀번호를 사용하는 다른 서비스에 접근할 수있다.
4. 가짜 서버로 위장하여 비밀번호를 가로챌 수 있다.

기본 인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송(SSL과 같은)과 함게 연계해서 사용할 수 있다. 이는 널리 사용하는 기술이다. 

